# Web Testing
Web apps are becoming more popular every day - as old fashioned view engines are being replaced by dynamic front-end
Javascript rendering frameworks, the need for testing increases. This is called web testing.

## Index
- [Testing Web Applications](#testing-web-applications)
- [Client-Server Model](#client-server-model)
- [Consequences of Accessibility](#consequences-of-accessibility)
- [Browsers](#browsers)
- [The Asynchronous Nature of Web Apps](#the-asynchronous-nature-of-web-apps)
- [Javascript Unit Testing (without frameworks)](#javascript-unit-testing-without-frameworks)
- [End-to-End Testing](#end-to-end-testing)
- [Page Objects](#page-objects)
- [Other Types of Tests](#other-types-of-tests)

## Testing Web Applications
Web testing is different from other forms of testing. The main focus of today's front-end is Javascript. This, of
course, calls for Javascript testing frameworks. And while many of the previously discussed testing techniques can also
be applied using these testing frameworks, they don't work exactly the same. This is mainly due to the difference in
**programming paradigms** between Java and Javascript. Java is an object oriented language, while Javascript is way more
flexible; you can use classes to do OOP, but you can also simply write top-level code in a functional manner if you'd
like. 

An important aspect of web testing is once again *design for testability*; many front-end frameworks like React, Vue or
Angular can help you with this. They are each Javascript rendering frameworks that allow you to split your code up in
components, which you can then combine to create content. Structuring your code using components is great, as you can
write unit tests for them. If you don't use them, however, you're in for some refactoring!

## Client-Server Model
Separating the front-end from the back-end and communicating over HTTP is often beneficial as it not only gives you more
control, but also forces you to think of some kind of interface that can help you connect both sides of your
application. Another benefit is that while the front-end of web applications must be written using HTML-CSS-JS (or just
JS), your backend can be written in whatever language you desire to use (regardless, use Node.js :^) ). This aspect,
however, can also impose additional challenges.

When building a full-scale web app, you probably want to test it with e2e tests, which means that your back end has to
be running while executing these tests. Your back end then has to be in the right state, your database has to contain
the right information, etc. As you can see, this model quite quickly became a lot bigger that you'd have thought.

## Consequences of Accessibility
On the web, everybody with a connection can access your app. This means that there is a high chance of your audience
being quite diverse. This makes **usability testing** and **accessibility testing** an important aspect of your tests;
you want to make sure people, wherever they are from, however old they are, have the same experience when visiting your
application.

Another important aspect is your back end server being able to handle all the load generated by users. This is done
using **load testing**. Of course people will also be trying to break your application, hence **security testing** is
very important.  

## Browsers
The front end of web applications runs in a browser. This creates a challenge, because there are many browsers, and they
don't all function the exact same way. Internet Explorer, for instance, is notorious for not supporting any new features
and is often seen as the browser that still lives somewhere 7in the 2000s.

To ensure that your app works on all (or most modern) browsers you can perform **cross-browser testing**. It's thus
important to test the responsiveness of your web app on multiple browsers, as not all browsers have the newest flexbox
features, for instance.

While this may sound strange, even your HTML should be designed for testability. This means that it should be easy to
select elements to test - you don't want your input box to consist of 10 nested, styled `div`s and then finally an
`input`, you would much rather have one `div`, or even none at all. You also want to make sure to assign appropriate
classes or ids.

As mentioned before, many front end frameworks use components. Testing these individual components is called
**UI component testing**. It is very similar to unit testing, as a component is simply a single unit of HTML+CSS+JS (one
unit in the DOM).

**Snapshot testing** can be applied to ensure your UI does not change unexpectedly. They usually work by comparing a
snapshot of a freshly rendered component or page, and comparing it to a reference snapshot (that is correct by
definition). If these snapshots don't match, the test fails. [Jest](https://jestjs.io/en/) makes this very easy to do
when using [React](https://reactjs.org/): [Jest Snapshot Testing](https://jestjs.io/docs/en/snapshot-testing).

## The Asynchronous Nature of Web Apps
Many web applications, especially single-page apps (SPAs) like the ones usually created with React, Vue or Angular,
function in an asynchronous manner. This means that you can use the app while requests are being still being made. This
is yet another advantage of the component model these frameworks adopt; instead of sending a whole page, you can send
each component individually, making each of them functional the moment they are received. It also brings to possibility
of not having to reload to visit another page. Instead, you just dynamically render the page using loaded components and
load additional components if needed.

Components are not the only resource delivered asynchronously, though. All content is usually also requested in a
separate REST API call. You can see this when you visit youtube; for a few milliseconds before the entire page has
loaded, placeholders are where videos should appear. This is because the web application has loaded, but the request for
a list of videos has not been answered yet.

While testing, it is important to wait for these components and resources to all have loading before performing any
tests.

A huge disadvantage of having to wait for resources before performing your tests is that it can cause **flaky tests**.
In other words, tests that pass or fail depending on some configuration. This makes it essential to somehow make your
tests more robust. You could, for instance, create some auto-retry logic.

## Javascript Unit Testing (without frameworks)
The [book](https://sttp.site/chapters/testing-into-context/web-testing.html) has examples. I won't copy them here, just
read the book. It nicely shows the advantage of creating components. It's kinda like using front end OOP.

It also does React stuff. I already know React + Jest, so I'm not gonna write anything about it.

## End-to-End Testing
The goal of e2e tests is to test the application as if it were live. For web apps, this usually means launching a
(headless) browser and checking whether stuff works. You can emulate actions a user would take and see if you get the
expected result. You could do this using `puppeteer` or Selenium WebDriver. Of course, you should not e2e test your
actual live application - you don't want actual payments to be made, emails to be sent out, etc.

## Page Objects
When e2e testing, you can communicate with a headless browser to fetch certain elements. This quickly becomes very
unreadable, though, as constantly using `findElementsWithClass(...)`, etc., to select elements is simply not easy to
read. A solution to this problem is creating **Page Objects**. Page objects are objects containing methods that use
WebDriver methods such as `findElementsWithClass(...)` to deliver usable information. You could compare them to DAOs
(Data Access Objects), as they help you get data. Now you can for instance use `getArtist(...)` to find the artist name
on an artist's page. This makes your tests much more readable. 

### State Objects
Page objects give us an abstraction for single pages or page fragments/components. As mentioned this is already better
than using WebDriver API, however you can take it even further by associating state to page objects. This creates
**state objects**. All your state objects form a *navigational state machine*, which can be used to test each part of
your application individually. These state objects can have *inspection methods* and *trigger methods*, which can be
used to fetch data from the current state or to emulate clicks, effectively changing the current state (just like page
objects). You can also apply **self-checking**. This means that you can have methods verify whether the state itself is
working correctly. For instance, you can check whether certain buttons - that should be clickable given the current
state - are actually clickable.

### Behavior-Driven Design
In *behavior-driven design*, you design with scenarios written in natural language in mind. You describe the system's
behavior in a certain situation/state, and then derive tests based on that. A basic structure for behavior-driven design
could be:
- Scenario Title
- Given ... (preconditions)
- When ... (trigger)
- Then ... (result)

An example from the book about an ATM:
```
As an Account Holder
I want to withdraw cash from an ATM
So that I can get money when the bank is closed

Scenario 1: Account has sufficient funds
Given the account balance is $100
 And the card is valid
 And the machine contains enough money
When the Account Holder requests $20
Then the ATM should dispense $20
 And the account balance should be $80
 And the card should be returned
```

Each scenario will be able to cover one transition in your navigational state machine.

## Other Types of Tests
There are a few other types of tests:

### Usability and Accessibility Testing
Usability and accessibility testing assert whether your application is actually usable by users, and accessibility
testing is used to check whether it is easy for users to figure out how your application works. All in all, it is
focused on user-friendliness, and making your app pleasant and easy to use. Accessibility includes making your app easy
to use for people with disabilities, such as blindness, deafness, learning disabilities, cognitive limitation, limited
movement, speech disabilities, sensitivity to light, etc.

One of the available tools that can help you with this is **axe**. Unfortunately many of these tests still have to be
done manually.

### Load and Performance Testing
This one is very straight forward. Load and performance testing entails testing whether your back-end can handle the
load your users bring. You want to make sure your app is usable as soon as possible, even if not everything has loaded
yet. There are various tools that can help you with this.
